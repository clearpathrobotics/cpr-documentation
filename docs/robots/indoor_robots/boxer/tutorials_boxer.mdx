---
title: Boxer Tutorials
sidebar_label: Tutorials
sidebar_position: 3
---

import ComponentIntroductionBoxer from "/components/introduction_boxer.mdx";
import ComponentPs4ControllerPairing from "/docs/components/ps4_controller_pairing.mdx";
import ComponentChangingDefaultPassword from "/docs/components/changing_default_password.mdx";
import ComponentWiredRobotConnection from "/docs/components/wired_robot_connection.mdx";
import ComponentWifiRobotConnection from "/docs/components/wifi_robot_connection.mdx";
import ComponentConfiguringNetworkBridge from "/docs/components/configuring_network_bridge.mdx";
import ComponentPerformingABackup from "/docs/components/performing_a_backup.mdx";
import ComponentInstallingRobotSoftware from "/docs/components/installing_robot_software.mdx";
import ComponentInstallingRemoteComputerSoftware from "/docs/components/installing_remote_computer_software.mdx";
import ComponentAddingASourceWorkspace from "/docs/components/adding_a_source_workspace.mdx";
import ComponentDrivingWithRemoteController from "/docs/components/driving_with_remote_controller.mdx";
import Support from "/components/support.mdx";

<ComponentIntroductionBoxer />

## Boxer Overview

:::caution

This guide is for the Boxer V2.4 (released in November 2021) and V2.5 (released in May 2023). Boxer V2.4 and V2.5 are not compatible with the older Boxer (V2.2).
Owners of previous-generation (V2.2) Boxers should refer to the documentation [here](http://www.clearpathrobotics.com/assets/guides/kinetic/boxer/).

:::

:::note

OTTO Motors and Clearpath Robotics operate under the same parent company.
Boxer V2.4 and V2.5 are a collaboration between the teams at OTTO Motors and Clearpath Robotics.

:::

### Introduction

Boxer is a large indoor mobile robot for prototyping and development of industrial applications.
It is a lightly modified [OTTO 100](https://ottomotors.com/amrs) robot, equipped with a Backpack Computer mounted
to the top of the Base Unit. This Backpack Computer communicates with the OTTO 100 via its attachment port, located
on the top of the Base Unit.

For more information or to receive a quote, please [visit us online](http://clearpathrobotics.com/boxer).

:::note

These tutorials assume that you are comfortable working with ROS.
We recommend starting with our [ROS tutorial](https://www.clearpathrobotics.com/assets/guides/noetic/ros/index.html) if you are not familiar with ROS already.

:::

:::note

These tutorials specifically target Boxer robots with a Backpack Computer running Ubuntu 20.04 with ROS Noetic, as it is the standard OS environment for Boxer.

:::

[Boxer ROS Packages](#boxer-ros-packages) provides the references for the software packages and key ROS topics.

[Boxer Software Setup](#boxer-software-setup) outlines the steps for setting up the software on your Boxer robot and optionally on a remote computer.

[Using Boxer](#using-boxer) describes how to simulate and drive your Boxer. [Simulation](#simulating-boxer) is a great way for most users to learn more about their Boxer;
understanding how to effectively operate Boxer in simulation is valuable whether you are in the testing phase with software you intend to ultimately deploy on a physical Boxer or you do not have one and are simply exploring the platform's capabilities.
[Driving Boxer](#driving-boxer) covers how to teleoperate Boxer using the remote control, as well as safety procedures for operating the physical robot.
Anyone working with a physical robot should be familiar with this section.

[Mapping and Navigating with Boxer](#navigating-boxer) is a follow-on to what is learned in the [Simulation](#simulating-boxer) tutorial, as navigation and map-making may be run in the simulated environment.
However, this content is applicable to both the simulator and the real platform, if your Boxer is equipped with a laser scanner.

[Boxer Tests](#testing-boxer) outlines how to validate that your physical Boxer is working correctly.

### Terminology

The following terms are used throughout this guide:

- Backpack Computer: the externally-mounted computer that has the ROS Master running on it.
- Base Unit: the OTTO 100 platform, including its internal computer. Sometimes referred to as "The OTTO 100".
- Boxer: the combined Base Unit and Backpack Computer.

### Differences from OTTO 100

The most obvious difference between OTTO 100 and Boxer V2.4/V2.5 is that Boxer has been painted black with a yellow
stripe on the sides. This change is purely cosmetic, and is to keep the Boxer visually distinct.

Mechanically, the top deck of the Boxer has a slightly thicker, heavier top-plate with a different arrangement of
mounting holes than the OTTO 100. This is to allow the attachment of additional payloads, such as robotic arms,
larger sensor arrays, and structural elements.

<center>
  <figure>
    <img
      src="/img/robot_images/boxer_images/boxer_dual_gen3_urdf.png"
      width="600"
    />
    <figcaption>URDF model of Boxer with two Kinova Gen3 arms</figcaption>
  </figure>
</center>

Finally, the OTTO 100's attachment interface and ROS2 API have been enabled. This is necessary to allow the
Backpack Computer to communicate with and control the robot.

### Operating Boxer

Boxer is intended to be controlled via the Backpack Computer; all necessary ROS nodes, and the ROS Master, are running on
the Backpack Computer. Any topics published by or subscribed to from the OTTO 100's internal computer are relayed from the
Backpack Computer.

When the robot powers on it will be in neutral. Use the OTTO App to disengage the safeties and enable operation of
the robot. Note that this requires that the Base Unit be connected to your wireless network. Refer to
[Network Setup](#boxer-networking) for more details.

One ethernet port of the Backpack Computer is reserved for communicating with the Base Unit. By default this is the
port identified as `eno1`, labelled "LAN1" on most computers. All other ethernet ports on the Backpack Computer are
bridged together and may be used for diagnostics, connecting external computers, or adding IP-based accessories such as
lidar sensors, cameras, or robotic arms.

### ROS2 API

OTTO Motors has developed a ROS2 API that is available to monitor and control the Base Unit. When using ROS Noetic,
Boxer uses `ros1_bridge` nodes to translate this ROS2 API into ROS1 compatible messages.

The ROS2 API operates on 3 domains:

| Domain ID | Description  |
| :-------- | :----------- |
| 100       | Fleet API    |
| 110       | Autonomy API |
| 95        | Platform API |

Refer to the [OTTO 100 documentation](https://ottomotors.com) for more details on the ROS2 API.

### Standard Sensors

The Base Unit includes a number of sensors whose data can be consumed by ROS nodes running on the Backpack Computer:

- front-facing safety lidar, available as `/front/scan`
- rear-facing safety lidar, available as `/rear/scan`
- internal IMU, available as `/imu/module0/data_raw`
- front-facing Intel RealSense camera
  - depth data available as `/realsense/depth/image_rect_raw`
  - depth camera info available as `/realsense/depth/camera_info`

At the time of writing OTTO Motors' ROS2 API does not expose pointcloud or RGB data from the RealSense camera

---

## Boxer ROS Packages {#boxer-ros-packages}

Boxer fully supports ROS. Boxer's Noetic packages are split into 5 repositories on Github:

- [Boxer](https://github.com/boxer-cpr/boxer): the core description and control packages, needed for physical and simulated robots
- [Boxer Robot](https://github.com/boxer-cpr/boxer_robot): core launch files and services needed for operating a physical Boxer
- [Boxer Simulation](https://github.com/boxer-cpr/boxer_simulation): Gazebo simulation packages for Boxer
- [Boxer Desktop](https://github.com/boxer-cpr/boxer_desktop): desktop visualization packages for Boxer
- [Boxer Manipulation](https://github.com/boxer-cpr/boxer_manipulation): optional support for robotic arms and grippers, including Kinova, Kuka, Robotiq, and UR

### Description Package {#description-package}

The [boxer_description](https://github.com/boxer-cpr/boxer/tree/noetic-devel/boxer_description) repository provides a [URDF](http://wiki.ros.org/urdf) model of Boxer.

Boxer's URDF model can be visualized in RViz.
Once you have installed the desktop software in an upcoming tutorial, you will be able to run:

```
roslaunch boxer_viz view_model.launch
```

<center>
  <figure>
    <img
      src="/img/robot_images/boxer_images/boxer_urdf.png"
      width="600"
    />
    <figcaption>Boxer model</figcaption>
  </figure>
</center>

### Environment Variables

Boxer can be customized and extended through the use of several environment variables.
The details are in the [boxer_description](https://github.com/boxer-cpr/boxer/tree/noetic-devel/boxer_description) repository.
Some of the most important ones are listed below.

| Variable               | Default            | Description                                                                                                                                                                                    |
| :--------------------- | :----------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ROS_ROBOT_SERIAL_NO`  | _undefined_        | The Boxer's serial number. This should be of the form `A31_0123456789` and must match the serial number stamped on the robot                                                                   |
| `BOXER_API_VERSION`    | `v1_1`             | The version of the OTTO SDK running on the Base Unit.                                                                                                                                          |
| `BOXER_URDF_EXTRAS`    | `empty.urdf.xacro` | Optional path to an additional URDF file to be added to the robot's description. Commonly used to add additional joints and links to add additional payloads, e.g. arms, additional sensors    |
| `BOXER_CONTROL_EXTRAS` | `empty.yaml`       | Optional path to a configuration file to override any of the Boxer's control parameters. Commonly used to change controller button mappings, EKF parameters, etc.                              |
| `BOXER_PC`             | `1`                | If `1` the URDF will include a model of the Backpack Computer. If `0` the Backpack Computer is omitted from the URDF. The shape of the mode is determined by the `BOXER_PC_MODEL` variable     |
| `BOXER_PC_MODEL`       | `evs-2000`         | Customizes the shape of the Backpack Computer added to the URDF. Other options are `ecx-2000` (for Vecow ECX-2000 series computer) and `mini-itx` (for common mini-ITX mini desktop enclosure) |
| `BOXER_PC_XYZ`         | `0 0 0`            | Defines the position of the Backpack Computer in the URDF relative to the Boxer's `top_plate_link`                                                                                             |
| `BOXER_PC_RPY`         | `0 0 0`            | Defines the orientation of the Backpack Computer in the URDF relative to the Boxer's `top_plate_link`                                                                                          |
| `BOXER_GPIO`           | `0`                | If `1` the GPIO pins on the PC can be controlled via a ROS node. **Not yet supported.**                                                                                                        |

### Key ROS Topics

You can view all topics that are active using `rostopic list`.

Your Boxer can be controlled through ROS, either through a ROS2 API on the Base Unit or through a ROS1 API on the optional Backpack Computer.
Some key topics that comprise the Boxer's ROS1 API are listed below.
For details on the ROS2 API, please contact Support.

| Topic                             | Message Type            | Purpose                                                                                                                                                                |
| :-------------------------------- | :---------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `/cmd_vel`                        | `geometry_msgs/Twist`   | Input to Boxer's kinematic controller. Publish here to make Boxer go.                                                                                                  |
| `/odom`                           | `nav_msgs/Odometry`     | Publishes the internal odometry from Boxer's Base Unit, a filtered localization estimate based on wheel odometry (encoders), an integrated IMU, a camera, and a laser. |
| `/imu/module0/data`               | `sensor_msgs/IMU`       | Publishes the internal IMU data from Boxer's Base Unit.                                                                                                                |
| `/front/scan`                     | `sensor_msgs/LaserScan` | Publishes the laser scan data from the Base Unit's front localization laser.                                                                                           |
| `/rear/scan`                      | `/rear/scan`            | Publishes the laser scan data from the Base Unit's rear safety laser.                                                                                                  |
| `/realsense/depth/image_rect_raw` | `sensor_msgs/Image`     | Publishes depth data from the Base Unit's camera.                                                                                                                      |

## Boxer Backpack Computer Software Setup {#boxer-software-setup}

:::caution

All of the software instructions in this section apply only to the Backpack Computer, not the
software running on the Base Unit. If your Boxer is not equipped with a Backpack Computer,
you can skip this section.

:::

### Backing Up Robot Configuration

Upgrading your Clearpath Boxer to ROS Noetic from older ROS distributions is a straightforward process;
however it's important to understand that each Boxer is different, having undergone customization to your specifications.
For more complete upgrade instructions see [this guide](https://clearpathrobotics.com/assets/guides/melodic/melodic-to-noetic/index.html).

Please take the time to understand what these modifications are, and how to recreate them on your fresh install of Ubuntu Focal/ROS Noetic.

#### Performing a Backup {#performing-a-backup}

<ComponentPerformingABackup />

### Installing and Configuring Robot Software

#### Installing Boxer Software

:::note

The physical Boxer robot comes pre-configured with ROS and the necessary Boxer packages already installed on the Backpack Computer;
therefore, you will only need to follow the instructions below if you are re-installing software on the Backpack Computer.

:::

:::note

To install these packages on your computer, ensure that you have added the ROS1 Noetic and ROS2 Foxy sources to your
`apt` configuration, as well as Clearpath's package server:

- [ROS1 Noetic](http://wiki.ros.org/noetic/Installation/Ubuntu)
- [ROS2 Foxy](https://docs.ros.org/en/foxy/Installation/Ubuntu-Install-Debians.html)
- [Clearpath Packages](http://packages.clearpathrobotics.com)

Note that Foxy is only needed if you plan on installing the `boxer_robot` packages; because of the OTTO 100's ROS2
API the Foxy version of `ros_bridge` is required to operate the physical robot.

:::

:::note

The `boxer_manipulation` packages are not available as .deb packages, because they have additional
dependencies that can only be installed from source. See below for details on building packages from source, and
refer to [boxer_manipulation on Github](https://github.com/boxer-cpr/boxer_manipulation) for more details on using
these packages.

:::

:::note

During the installation process, you will be asked to enter the robot's serial number. This is stamped on the
back of the robot, and will be of the form `A31_` followed by a series of numbers. It is important that this serial
number be entered correctly. Otherwise you may have errors communicating with the ROS2 API published by the Base Unit.

:::

:::note

The OS installation will require an internet connection via ethernet. When connecting an Ethernet cable to Boxer,
make sure to use the `eno1` Ethernet port on the Backpack Computer, not the Ethernet port on the Base Unit.
This `eno1` port is the same port normally used for communicating with the Base Unit. If eno1 (sometimes labelled "LAN1")
is connected to the Base Unit, disconnect the Base Unit for now. Once the OS has installed you can reconnect the base
platform to `eno1`. You will also need to connect a monitor and keyboard to the Backpack Computer. We recommend connecting the Boxer
to its charger during the installation process to ensure it doesn't lose power.

:::

<ComponentInstallingRobotSoftware />

#### Configuring the Backpack Computer

If you are installing the packages on Boxer's Backpack Computer, you will need to set up `/etc/ros/setup.bash`
too:

```
# Mark location of self so that robot_upstart knows where to find the setup file.
export ROBOT_SETUP=/etc/ros/setup.bash

# Setup robot upstart jobs to use the IP from the network bridge.
# export ROBOT_NETWORK=br0

# Insert extra platform-level environment variables here. The six hashes below are a marker
# for scripts to insert to this file.
######

# Pass through to the main ROS workspace of the system.
source /opt/ros/noetic/setup.bash

# Source your catkin workspace
# Make sure to use the complete path, and avoid using envars like $HOME
# Omit this if you do not have a workspace
source /home/administrator/catkin_ws/devel/setup.bash

# Set the ROS_ROBOT_SERIAL_NO and BOXER_API_VERSION envars
# this is required for the Boxer to operate correctly
# The serial number must match the one stamped on the back of the robot
export ROS_ROBOT_SERIAL_NO=A31_0123456789
export BOXER_API_VERSION=v1_3

# Any additional environment variables that depend on your workspace should be exported here
# e.g.
#export BOXER_URDF_EXTRAS=/path/to/boxer_customizations.urdf.xacro
```

The `BOXER_API_VERSION` environment variable must be set on the robot's Backpack Computer. This version is determined by
the version of the ROS2 API running on the Base Unit.

At the time of writing the latest version of the OTTO software uses `v1_3`

The `ROS_ROBOT_SERIAL_NO` environment variable must match the serial number stamped on the back of the robot.
The serial number is case-sensitive, and will begin with `A31_`, followed by a series of numbers.

Finally, after you have configured `/etc/ros/setup.bash` you can run the following to create the ROS systemd jobs
that will start ROS automatically when the Backpack Computer start up:

```
source /etc/ros/setup.bash
rosrun boxer_bringup install
sudo systemctl daemon-reload
sudo systemctl start ros
sudo systemctl start ros-bridge
```

#### Testing Base Configuration

You can check that the service has started correctly by checking the logs:

```
sudo journalctl -u ros
```

Your Boxer should now be accepting commands from your joystick (see next section).
The service will automatically start each time you boot your Boxer's computer.

#### Pairing the Controller {#pairing-the-controller}

##### PS4 Controller

<ComponentPs4ControllerPairing />

### Setting up Boxer's Network Configuration {#boxer-networking}

Boxer is normally equipped with a combination Wi-Fi + Bluetooth module.
If this is your first unboxing, ensure that Boxer's wireless antennae are firmly screwed on to the chassis.
Boxer is equipped with a Backpack Computer mounted to the top of the Base Unit. The Base Unit is
also equipped with an internal computer. This section explains how to configure the networking for the Backpack Computer only. For
instructions on connecting the Base Unit's computer to a network, refer to the [OTTO 100 Documentation](https://docs.ottomotors.com).

#### Enabling the OTTO App

Many of Boxer's features are accessible via the OTTO App. This requires configuring the Base Unit to connect
to your Wi-Fi network. To do this, connect your laptop to the diagnostic ethernet port on the rear of the Base Unit.
Configure your laptop to have a static IP address on the 10.255.255.0/16 subnet, e.g. 10.255.255.100.

Open a web browser and navigate to http://10.255.255.1:8090. You will be promted to enter your network credentials.

Refer to [OTTO Motors' documentation](https://docs.ottomotors.com/en/30495-30526-connecting-a-robot-to-a-network.html)
for more details on configuring the Base Unit's networking.

#### First Connection

By default, Boxer Backpack Computer's Wi-Fi is in client mode, looking for the wireless network at the Clearpath factory.

<ComponentWiredRobotConnection />

#### Changing the Default Password

<ComponentChangingDefaultPassword />

#### Wi-Fi Setup

<ComponentWifiRobotConnection />

### Installing Remote Computer Software {#remote-computer-software}

:::note

This step is optional.

:::

<ComponentInstallingRemoteComputerSoftware />

#### Adding a Source Workspace

<ComponentAddingASourceWorkspace />

#### Reconfiguring the Network Bridge

In the event you must modify Boxer's ethernet bridge, you can do so by editing the Netplan configuration file
found at `/etc/netplan/50-clearpath-bridge.yaml`:

```
network:
  version: 2
  renderer: networkd
  ethernets:
    # Configure eno1 to communicate with the OTTO 100 internal computer via the attachment port
    eno1:
      dhcp4: no
      dhcp6: no
      addresses:
        - 10.252.252.100/16

    # Bridge all the remaining ethernet ports together
    bridge_eth:
      dhcp4: no
      dhcp6: no
      match:
        name: eth*
    bridge_enp:
      dhcp4: no
      dhcp6: no
      match:
        name: enp*
    bridge_enx:
      dhcp4: no
      dhcp6: no
      match:
        name: enx*
  bridges:
    br0:
      # yes, allow DHCP4 connections on the bridge; this allows the Backpack Computer to accept
      # wired internet connections, e.g. for installing updates
      dhcp4: yes
      dhcp6: no
      interfaces: [bridge_eth, bridge_enp, bridge_enx]
      addresses:
        # Give the bridge the static 192.168.131.1 address for its internal ROS network
        # Any IP-based ROS sensors connected to the backpack should use the 192.168.131.0/24 subnet
        - 192.168.131.1/24
```

This file will create a bridged interface called `br0` that will have a static address of 192.168.131.1, but will
also be able to accept a DHCP lease when connected to a wired router. By default all network ports named `en*` and
`eth*` are added to the bridge. This includes all common wired port names, such as:

- `eth0`
- `eno1`
- `enx0123456789ab`
- `enp3s0`
- etc

To include/exclude additional ports from the bridge, edit the `match` fields, or add additional `bridge_*` sections
with their own `match` fields, and add those interfaces to the `interfaces: [bridge_en, bridge_eth]` line near the
bottom of the file.

We do not recommend changing the static address of the bridge to be anything other than `192.168.131.1`; changing
this may cause sensors that communicate over ethernet (e.g. lidars, cameras, GPS arrays) from working properly.

---

## Using Boxer {#using-boxer}

### Simulating Boxer {#simulating-boxer}

Whether you actually have a Boxer robot or not, the Boxer simulator is a great way to get started with ROS robot development.
In this tutorial, we will go through the basics of starting Gazebo and RViz and how to drive your Boxer around.

#### Installation

To get started with the Boxer simulation, make sure you have a [working ROS installation](#remote-computer-software) set up on your Ubuntu desktop, and install the Boxer-specific metapackages for desktop and simulation:

```
sudo apt-get install ros-noetic-boxer-simulator ros-noetic-boxer-desktop
```

#### Launching Gazebo

[Gazebo](https://gazebosim.org/home) is the most common simulation tool used in ROS. Boxer's model in Gazebo include reasonable approximations of its dynamics, including wheel slippage, skidding, and inertia.
To launch simulated Boxer in a simple example world, run the following command:

```
roslaunch boxer_gazebo boxer_world.launch
```

You should see the following window appear, or something like it.
You can adjust the camera angle by clicking and dragging while holding CTRL, ALT, or the Shift key.

<center>
  <figure>
    <img
      src="/img/robot_images/boxer_images/boxer_gazebo.png"
      width="800"
    />
    <figcaption>Simulated Boxer</figcaption>
  </figure>
</center>

The window which you are looking at is the Gazebo Client.
This window shows you the "true" state of the simulated world which the robot exists in.
It communicates on the backend with the Gazebo Server, which is doing the heavy lifting of actually maintaining the simulated world.
At the moment, you are running both the client and server locally on your own machine, but some advanced users may choose to run heavy duty simulations on separate hardware and connect to them over the network.

:::note

When simulating, you must leave Gazebo running.
Closing Gazebo will prevent other tools, such as RViz (see below) from working correctly.

:::

#### Launching RViz

The next tool we will encounter is [RViz](http://wiki.ros.org/rviz).
Although superficially similar in appearance to Gazebo, RViz has a very different purpose. Unlike Gazebo, which shows the reality of the simulated world, RViz shows the robot's _perception_ of its world, whether real or simulated.
So while Gazebo won't be used with your real Boxer, RViz is used with both.

You can use the following launch invocation to start RViz with a predefined configuration suitable for visualizing any standard Boxer config.

```
roslaunch boxer_viz view_robot.launch
```

You should see RViz appear.

<center>
  <figure>
    <img
      src="/img/robot_images/boxer_images/boxer_rviz.png"
      width="800"
    />
    <figcaption>Boxer RViz</figcaption>
  </figure>
</center>

The visualization shows the depth data from the Base Unit's RealSense camera (the rainbow-colored points) as well as the data from the front and rear lidars.

#### Driving with Interactive Controller

RViz will also show Boxer's interactive markers around your Boxer's model.
These will appear as a blue ring and red arrows.
Depending on your robot, there will also be green arrows.
If you don't see them in your RViz display, select the Interact tool from the top toolbar and they should appear.

Drag the red arrows in RViz to move in the linear X direction, and the blue circle to move in the angular Z direction.
If your robot supports lateral/sideways movement, you can drag the green arrows to move in the linear Y direction.
RViz shows you Boxer moving relative to its odometric frame, but it is also moving relative to the simulated world supplied by Gazebo.
If you click over to the Gazebo window, you will see Boxer moving within its simulated world.
Or, if you drive real Boxer using this method, it will have moved in the real world.

All of Clearpath's robots use the same coordinate system, shown below:

<center>
  <figure>
    <img
      src="/img/robot_images/boxer_images/coords.png"
      width="600"
    />
    <figcaption>Boxer Coordinate System</figcaption>
  </figure>
</center>

| Axis       | Positive Meaning       | Negative Meaning        |
| :--------- | :--------------------- | :---------------------- |
| X          | Linear motion forwards | Linear motion backwards |
| Y          | Linear motion left     | Linear motion right     |
| Z          | Linear motion up       | Linear motion down      |
| X^ (roll)  | Roll to the right      | Roll to the left        |
| Y^ (pitch) | Pitch down             | Pitch up                |
| Z^ (yaw)   | Rotate left            | Rotate right            |

Boxer, in its default configuration, will treat the linear Y and Z axes, as well a the angular X and Y axes, as zero
at all times; the robot is incapable of moving in these directions.

Once you start your own development, have your nodes send `geometry_msgs/Twist` commands to the `cmd_vel`
topic to drive Boxer, either real or simulated. This is the standard ROS interface to differential-drive and
holonomic ground vehicles.

The `geometry_msgs/Twist` message includes fields for linear X/Y/Z in m/s, as well as fields for angular X/Y/Z
in rad/s.

```
$ rosmsg info geometry_msgs/Twist
geometry_msgs/Vector3 linear
  float64 x
  float64 y
  float64 z
geometry_msgs/Vector3 angular
  float64 x
  float64 y
  float64 z
```

#### Control

There are three ways to send your Boxer control commands:

1.  Using the provided PS4 controller.
    Refer to the [User Manual](./user_manual_boxer/#controller) details on how to use the controller.

2.  Using the RViz instance above.
    If you select the Interact option in the top toolbar, an interactive marker will appear around the Boxer and can be used to control speed.

3.  The [rqt_robot_steering plugin](http://wiki.ros.org/rqt_robot_steering).
    Run the `rqt` command, and select **Plugins→Robot Tools→Robot Steering** from the top menu.

Boxer uses [twist_mux](http://wiki.ros.org/twist_mux) to mix separate [geometry_msgs\Twist](http://docs.ros.org/api/geometry_msgs/html/msg/Twist.html) control channels into the `/cmd_vel` topic.

Additional velocity channels can be defined in [twist_mux.yaml](https://github.com/boxer-cpr/boxer/blob/noetic-devel/boxer_control/config/twist_mux.yaml), or can be piped into the lowest-priority `/cmd_vel` topic.

#### Additional Simulation environments

Boxer is supported by Clearpath's [additional simulation environments](https://github.com/clearpathrobotics/cpr_gazebo).
To use these environments, clone the repository into your workspace and build it:

```
cd $HOME/catkin_ws/src
git clone https://github.com/clearpathrobotics/cpr_gazebo.git -b noetic-devel
cd ..
rosdep install --from-paths src --ignore-src --rosdistro=noetic -r
catkin_make
source devel/setup.bash
```

Note that you may get warnings about missing dependencies for e.g. `warthog_gazebo` or `jackal_gazebo`. These
dependencies are only needed if you intend to simulate Clearpath's other robotic platforms in these environments.
If you only intend to simulate Boxer, you can safely ignore these missing dependencies.

Because Boxer is an indoor platform, it is only usable in the `cpr_office_gazebo` and `cpr_obstacle_gazebo` environments

To launch Boxer in the office environment, use:

```
roslaunch cpr_office_gazebo office_world.launch platform:=boxer
```

<center>
  <figure>
    <img
      src="/img/robot_images/boxer_images/boxer_office_gazebo.png"
      width="800"
    />
    <figcaption>Boxer in the Office World</figcaption>
  </figure>
</center>

To launch Boxer in the obstacle environment, use

```
roslaunch cpr_obstacle_gazebo cpr_obstacle_world.launch platform:=boxer
```

<center>
  <figure>
    <img
      src="/img/robot_images/boxer_images/boxer_obstacle_gazebo.png"
      width="800"
    />
    <figcaption>Boxer in the Obstacle World</figcaption>
  </figure>
</center>

### Driving Boxer {#driving-boxer}

There are four ways to drive Boxer and each way will work on a physical Boxer robot as well as on a simulated Boxer.

1.  Using the interactive remote controller in RViz. See [Simulating Boxer](#simulating-boxer).
2.  Using autonomous navigation. See [Navigating Boxer](#navigating-boxer).
3.  Using the controller for teleoperation. See below.
4.  Publishing ROS messages. See below.

:::warning

Boxer is capable of reaching high speeds.
Careless driving can cause harm to the operator, bystanders, the robot, or other property.
Always remain vigilant, ensure you have a clear line of sight to the robot, and operate the robot at safe speeds.
We strongly recommend driving in normal (slow) mode first, and only enabling turbo in large, open areas that are free of people and obstacles.

:::

#### Driving with Remote Controller

:::note

For instructions on controller pairing, see [Pairing the Controller](#pairing-the-controller).

:::

<ComponentDrivingWithRemoteController />

#### Driving with ROS Messages

You can manually publish `geometry_msgs/Twist` ROS messages to the `/cmd_vel` ROS topic to drive Boxer.

For example, in terminal, run:

```
rostopic pub /cmd_vel geometry_msgs/Twist '{linear: {x: 0.5, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}'
```

The command above makes Boxer drive forward momentarily at 0.5 m/s without any rotation.

### Extending Boxer Startup

Now that you've had Boxer for a while, you may be interested in how to extend it, perhaps add some more payloads, or augment the URDF.

#### Startup Launch Context

When ROS packages are grouped together in a directory and then built as one, the result is referred to as a workspace.
Each workspace generates a `setup.bash` file which the user may source in order to correctly set up important environment variables such as `PATH`, `PYTHONPATH`, and `CMAKE_PREFIX_PATH`.

The standard system-wide setup file is in `/opt`:

```
source /opt/ros/noetic/setup.bash
```

When you run this command, you'll have access to `rosrun`, `roslaunch`, and all the other tools and packages installed on your system from Debian packages.

However, sometimes you want to add additional system-specific environment variables, or perhaps packages built from source.
For this reason, Clearpath platforms use a wrapper setup file, located in `/etc/ros`:

```
source /etc/ros/setup.bash
```

This is the setup file which gets sourced by Boxer's background launch job, and in the default configuration, it is also sourced on your login session.
For this reason it can be considered the "global" setup file for Boxer's ROS installation.

This file sets some environment variables and then sources a chosen ROS workspace, so it is one of your primary modification points for altering how Boxer launches.

#### Launch Files

The second major modification point is the `/etc/ros/noetic/ros.d` directory.
This location contains the launch files associated with the `ros` background job.
If you add launch files here, they will be launched with Boxer's startup.

However, it's important to note that in the default configuration, any launch files you add may only reference ROS software installed in `/opt/ros/noetic`.
If you want to launch something from workspace in the home directory, you must change `/etc/ros/setup.bash` to source that workspace's setup file rather than the one from `/opt`.

#### Adding URDF

There are two possible approaches to augmenting Boxer's URDF.
The first is that you may simply set the `BOXER_URDF_EXTRAS` environment variable in `/etc/ros/setup.bash`.
By default, it points to an empty dummy file, but you can point it to a file of additional links and joints which you would like mixed into Boxer's URDF (via xacro) at runtime.

The second, more sophisticated way to modify the URDF is to create a _new_ package for your own robot, and build your own URDF which wraps the one provided by [boxer_description](https://github.com/boxer-cpr/boxer/tree/noetic-devel/boxer_description).

### Keeping Boxer Updated

For details on updating Boxer software or firmware, refer to [Software Maintenance](./maintenance_boxer#software_maintenance).

---

## Mapping and Navigating with Boxer {#navigating-boxer}

:::note

Boxer includes the latest autonomy software from OTTO, including [Fleet Manager](https://ottomotors.com/fleet-manager).

Please refer to [OTTO Motors' documentation](https://docs.ottomotors.com) and the OTTO 100 user manual
for details on how to use OTTO's advanced autonomy software

:::

This section explains how to use basic navigation demos with Boxer. These examples can be used with a simulated Boxer
or with the physical robot. Note that if you are using the physical Boxer you also have access to the much more
advanced OTTO autonomy software.

To get all Navigation related files for Boxer, run:

```
sudo apt-get install ros-noetic-boxer-navigation
```

Below are the example launch files for three different configurations for navigating Boxer:

- Navigation in an odometric frame without a map, using only [move_base](http://wiki.ros.org/move_base).
- Generating a map using [Gmapping](http://wiki.ros.org/gmapping).
- Localization with a known map using [amcl](http://wiki.ros.org/amcl).

If you are working in a simulation, bring up Boxer using the following command:

```
roslaunch boxer_gazebo boxer_race.launch
```

This will spawn Boxer in a relatively enclosed environment

<center>
  <figure>
    <img
      src="/img/robot_images/boxer_images/boxer_gazebo_race.png"
      width="800"
    />
    <figcaption>Boxer in its simulated environment</figcaption>
  </figure>
</center>

If you're working with a real Boxer, it's suggested to connect wirelessly via SSH and launch the ROS launch files from onboard the robot.
You'll need to have bidirectional communication with the robot's roscore in order to launch RViz on your workstation (see [here](#remote-computer-software)).

### Navigation without a Map

In the odometry navigation demo Boxer attempts to reach a given goal in the world within a user-specified tolerance.
The 2D navigation, generated by `move_base`, takes in information from odometry, laser scanner, and a goal pose and outputs safe velocity commands.
In this demo the configuration of move_base is set for navigation without a map in an odometric frame (that is, without reference to a map).

To launch the navigation demo, run:

```
roslaunch boxer_navigation odom_navigation_demo.launch
```

To visualize with the suggested RViz configuration launch:

```
roslaunch boxer_viz view_robot.launch config:=navigation
```

<center>
  <figure>
    <img
      src="/img/robot_images/boxer_images/boxer_rviz_odom_navigating.png"
      width="800"
    />
    <figcaption>Boxer driving to its 2D Nav Goal in RViz</figcaption>
  </figure>
</center>

To send goals to the robot, select the _2D Nav Goal_ tool from the top toolbar, and then click anywhere in the RViz view to set the position.
Alternatively, click and drag slightly to set the goal position and orientation.

If you wish to customize the parameters of move_base, local costmap, global costmap and base_local_planner, clone [boxer_navigation](https://github.com/boxer-cpr/boxer/tree/noetic-devel/boxer_navigation) into your own workspace and modify the corresponding files in the `params` subfolder.

### Making a Map {#gmapping-demo}

Gmapping is an open-source tool for Simultaneous Localization And Mapping, or SLAM. SLAM allows a robot to build a
map of its environment while exploring, making it helpful when the robot is in unfaimilar environments.

This section explains how to produce a map using Gmapping. We will use this map to set 2D nav goals in the
following section.

To begin, run the following command:

```
roslaunch boxer_navigation gmapping.launch
```

And on your workstation, launch RViz with the suggested configuration:

```
roslaunch boxer_viz view_robot.launch config:=gmapping
```

:::note

If you are driving a simulated Boxer you may find it easyer to launch RViz without the gmapping configuration:

```
roslaunch boxer_viz view_robot.launch
```

:::

<center>
  <figure>
    <img
      src="/img/robot_images/boxer_images/boxer_rviz_gmapping.png"
      width="800"
    />
    <figcaption>RViz with Boxer's Gmapping configuration</figcaption>
  </figure>
</center>

Now slowly drive the robot around to produce a map. If you are driving the robot using the interactive controls in
RViz you may find it helpful to change the visulaization's fixed frame from `map` or `odom` to `base_link`. Doing
so will keep the robot in a fixed position in the window, while the world rotates around the robot.

When you're satisfied, you can save the produced map using [map_saver](http://wiki.ros.org/map_server#map_saver):

```
rosrun map_server map_saver -f mymap
```

This will create a `mymap.yaml` and `mymap.pgm` file in your current directory.

The resulting map should look something like this:

<center>
  <figure>
    <img
      src="/img/robot_images/boxer_images/boxer_race_map.png"
      width="800"
    />
    <figcaption>Boxer's exported map</figcaption>
  </figure>
</center>

### Navigation with a Map

Using [amcl](http://wiki.ros.org/amcl), Boxer is able to globally localize itself in a known map.
AMCL takes in information from odometry, laser scanner and an existing map and estimates the robot's pose.

To start the AMCL demo:

```
roslaunch boxer_navigation amcl_demo.launch map_file:=/path/to/my/map.yaml
```

If you don't specify `map_file`, it defaults to an included pre-made map of the default "Boxer World" environment which Boxer's simulator spawns in.
If you're using a real Boxer in your own environment, you'll definitely want to override this with the map created using the Gmapping demo.

Before navigating, you need to initialize the localization system by setting the pose of the robot in the map.
This can be done using 2D Pose Estimate in RViz or by setting the amcl `initial_pose` parameters. To visualize with the suggested RViz configuration launch:

```
roslaunch boxer_viz view_robot.launch config:=localization
```

When RViz appears, select the _Set 2D Pose tool_ from the toolbar, and click on the map to indicate to the robot approximately where it is.

### Advanced Mapping

If you have an application which requires faster or more accurate SLAM capabilities, our commercial offerings
may be a good fit for your team. Please [get in touch for more details](http://www.clearpathrobotics.com/contact/).

---

## Boxer Tests {#testing-boxer}

Boxer robots come preinstalled with a set of test scripts as part of the `boxer_tests` ROS package, which can be run to verify robot functionality at the component and system levels.

If your Boxer does not have the `boxer_tests` ROS package installed already, you can manually install it by opening terminal and running:

```
sudo apt-get install ros-noetic-boxer-tests
```

### ROS Tests

The `ros_tests` script exposes a set of interactive tests to verify the functionality of core features.
These tests run at the ROS-level via ROS topics, and serve as a useful robot-level diagnostic tool for identifying the root cause of problems, or at the very least, narrowing down on where the root cause(s) may be.

#### Running ROS Tests

To run `ros_tests` on a Boxer robot, open terminal and run:

```
rosrun boxer_tests ros_tests
```

Upon running `ros_tests`, a list of available tests will be shown in a menu.
From the menu, you can choose individual tests to run, or simply choose the option to automatically run all the tests.

The details of each test are shown below.

- **Serial Number Test**

  The **Serial Number Test** checks that the robot's serial number is set correctly.

  This test checks the `ROS_ROBOT_SERIAL_NO` environment variable is set to a valid serial number.

- **API Version Test**

  The **API Version Test** checks that the robot's API version is set correctly.

  This test checks the `BOXER_API_VERSION` environment variable is set to a valid API version, and that the robot is publishing data on ROS topics under this API version.

- **ROS Bridge Test**

  The **ROS Bridge Test** checks that the ROS bridge is working properly, and that the robot's description model is loaded.

  This test checks that the list of expected ROS topics from the ROS bridge exist, and that these ROS topics are publishing data at the expected frequencies. The expected ROS topics are published by the robot's Base Unit, and the ROS bridge "bridges" these ROS topics to the robot's Backpack Computer, including the Base Unit's IMU, camera, laser, and battery data.

  This test also the robot's model is loaded into the `robot_description` ROS parameter.

- **Emergency Stop Test**

  The **Emergency Stop Test** checks that the robot's emergency stop is working properly.

  This test subscribes to the `/platform/emergency_stop` ROS topic and checks that when the emergency stop is manually engaged and disengaged by the user, the emergency stop states are correctly reported on the `/platform/emergency_stop` ROS topic.

- **Rotate Test**

  The **Rotate Test** rotates the robot counter clockwise 2 full revolutions and checks that the motors, IMU, and EKF odometry are working properly.

  This test:

  - Subscribes to the `/imu/module1/data` ROS topic to receive angular velocity measurements from the IMU's Gyroscope. These measurements are converted into angular displacement estimations, and the robot will rotate until 2 full revolutions are estimated.
  - Subscribes to the `/odom` ROS topic to receive angular velocity estimations from the EKF odometry. These measurements are converted into angular displacement estimations, and are output as comparison to the angular displacement estimations from the IMU's Gyroscope.
  - Publishes to the `/cmd_vel` ROS topic to send drive commands to rotate the robot.
  - The user will be asked to verify that the robot rotates 2 full revolutions.

  :::note

  The **Rotate Test** rotates the robot using the IMU's Gyroscope data, which inherently will not be 100% accurate.
  Therefore, some undershoot/overshoot is to be expected.

  :::

- **Drive Test**

  The **Drive Test** drives the robot forward 1 metre and checks that the motors, and EKF odometry are working properly.

  This test:

  - Subscribes to the `/odom` ROS topic to receive linear displacement estimations from the EKF odometry. The robot will drive forward until 1 metre is estimated, then it will drive backward until 1 metre is estimated.
  - Publishes to the `/cmd_vel` ROS topic to send drive commands to drive the robot.
  - The user will be asked to verify that the robot drives forward 1 metre.

  :::note

  The **Drive Test** drives the robot using the Odometry data, which inherently will not be 100% accurate.
  Therefore, some undershoot/overshoot is to be expected.

  :::
