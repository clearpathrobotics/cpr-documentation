---
title: Ridgeback Tutorials
sidebar_label: Tutorials
sidebar_position: 4
---

import ComponentIntroductionRidgeback from "/components/introduction_ridgeback.mdx";
import ComponentPs4ControllerPairing from "/components/ps4_controller_pairing.mdx";
import ComponentChangingDefaultPassword from "/components/changing_default_password.mdx";
import ComponentWiredRobotConnection from "/components/wired_robot_connection.mdx";
import ComponentWifiRobotConnection from "/components/wifi_robot_connection.mdx";
import ComponentConfiguringNetworkBridge from "/components/configuring_network_bridge.mdx";
import ComponentPerformingABackup from "/components/performing_a_backup.mdx";
import ComponentInstallingRobotSoftware from "/components/installing_robot_software.mdx";
import ComponentInstallingRemoteComputerSoftware from "/components/installing_remote_computer_software.mdx";
import ComponentAddingASourceWorkspace from "/components/adding_a_source_workspace.mdx";
import ComponentDrivingWithRemoteController from "/components/driving_with_remote_controller.mdx";
import Support from "/components/support.mdx";

<ComponentIntroductionRidgeback />

## Ridgeback Overview

### Introduction

Ridgeback is a rugged, indoor omnidirectional platform designed to move manipulators and other heavy
payloads with ease and precision. These tutorials will assist you with setting up and operating your Ridgeback.
The tutorial topics are listed in the right column and presented in the suggested reading order.

For more information or to receive a quote, please [visit us online](http://clearpathrobotics.com/ridgeback).

:::note

These tutorials assume that you are comfortable working with ROS.
We recommend starting with our [ROS tutorial](https://www.clearpathrobotics.com/assets/guides/noetic/ros/index.html) if you are not familiar with ROS already.

:::

:::note

These tutorials specifically target Ridgeback robots running Ubuntu 20.04 with ROS Noetic, as it is the standard OS environment for Ridgeback.
If instead you have an older Ridgeback robot running Ubuntu 18.04 with ROS Melodic, please follow [this tutorial](https://www.clearpathrobotics.com/assets/guides/melodic/melodic-to-noetic/index.html) to upgrade the robot OS environment to Ubuntu 20.04 with ROS Noetic.

:::

[Ridgeback ROS Packages](#ridgeback-ros-packages) provides the references for the software packages and key ROS topics.

[Ridgeback Software Setup](#ridgeback-software-setup) outlines the steps for setting up the software on your Ridgeback robot and optionally on a remote computer.

[Using Ridgeback](#using-ridgeback) describes how to simulate and drive your Ridgeback. [Simulation](#simulating-ridgeback) is a great way for most users to learn more about their Ridgeback;
understanding how to effectively operate Ridgeback in simulation is valuable whether you are in the testing phase with software you intend to ultimately deploy on a physical Ridgeback or you do not have one and are simply exploring the platform's capabilities.
[Driving Ridgeback](#driving-ridgeback) covers how to teleoperate Ridgeback using the remote control, as well as safety procedures for operating the physical robot.
Anyone working with a physical robot should be familiar with this section.

[Navigating Ridgeback](#navigating-ridgeback) is a follow-on to what is learned in the [Simulation](#simulating-ridgeback) tutorial, as navigation and map-making may be run in the simulated environment.
However, this content is applicable to both the simulator and the real platform, if your Ridgeback is equipped with a laser scanner.

[Ridgeback Tests](#testing-ridgeback) outlines how to validate that your physical Ridgeback is working correctly.

[Advanced Topics](#advanced-topics) covers items that are only required in atypical situations.

---

## Ridgeback ROS Packages {#ridgeback-ros-packages}

Ridgeback fully supports ROS; all of the packages are available in [Ridgeback Github](https://github.com/ridgeback).

### Description Package {#description-package}

The [ridgeback_description](https://github.com/ridgeback/ridgeback/tree/melodic-devel/ridgeback_description) repository provides a [URDF](http://wiki.ros.org/urdf) model of Ridgeback.

Ridgeback's URDF model can be visualized in RViz.
Once you have installed the desktop software in an upcoming tutorial, you will be able to run:

```
roslaunch ridgeback_viz view_model.launch
```

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_urdf.png"
      width="600"
    />
    <figcaption>Ridgeback model</figcaption>
  </figure>
</center>

### Environment Variables

Ridgeback can be customized and extended through the use of several environment variables.
The details are in the [ridgeback_description](https://github.com/ridgeback/ridgeback/tree/melodic-devel/ridgeback_description) repository.
Some of the most important ones are listed below.

| Variable                       | Default | Description                                                                            |
| :----------------------------- | :------ | :------------------------------------------------------------------------------------- |
| `RIDGEBACK_FRONT_HOKUYO_LASER` | `0`     | Set to `1` if the robot is equipped with a front-facing Hokuyo LIDAR unit (e.g. UST10) |
| `RIDGEBACK_REAR_HOKUYO_LASER`  | `0`     | Set to `1` if the robot is equipped with a rear-facing Hokuyo LIDAR unit (e.g. UST10)  |
| `RIDGEBACK_FRONT_SICK_LASER `  | `0`     | Set to `1` if the robot is equipped with a front-facing SICK LMS-111 LIDAR unit        |
| `RIDGEBACK_REAR_SICK_LASER `   | `0`     | Set to `1` if the robot is equipped with a rear-facing SICK LMS-111 LIDAR unit         |
| `RIDGEBACK_MICROTRAIN_IMU`     | `0`     | Set to `1` if the robot is equipped with a Microstrain IMU                             |

### Configurations

As an alternative to individually specifying each accessory, some fixed configurations are provided in the package.
These can be specified using the `config` arg to `description.launch`, and are intended especially as a convenience for simulation launch.

| Config               | Description                                 |
| :------------------- | :------------------------------------------ |
| `base`               | Base Ridgeback                              |
| `base_sick`          | Ridgeback with front SICK laser             |
| `dual_hokuyo_lasers` | Ridgeback with front and rear Hokuyo lasers |
| `dual_sick_lasers`   | Ridgeback with front and rear SICK lasers   |

### Key ROS Topics

You can view all topics that are active using `rostopic list`.
The most important topics are summarized in the table below.

| Topic                | Message Type            | Purpose                                                                                                                                                                           |
| :------------------- | :---------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `/cmd_vel`           | `geometry_msgs/Twist`   | Input to Ridgeback's kinematic controller. Publish here to make Ridgeback go.                                                                                                     |
| `/odometry/filtered` | `nav_msgs/Odometry`     | Published by `robot_localization`, a filtered localization estimate based on wheel odometry (encoders) and integrated IMU.                                                        |
| `/imu/data`          | `sensor_msgs/IMU`       | Published by `imu_filter_madgwick`, an orientation estimated based on the Ridgeback's internal IMU.                                                                               |
| `/mcu/status`        | `ridgeback_msgs/Status` | Low-frequency status data for Ridgeback's systems. This information is republished in human readable form on the `diagnostics` topic and is best consumed with the Robot Monitor. |
| `/mcu/cmd_fans`      | `ridgeback_msgs/Fans`   | User can publish to this topic to control an the installed fans.                                                                                                                  |
| `/cmd_lights`        | `ridgeback_msgs/Lights` | User can publish to this topic to override the default behavior of the Ridgeback body lights.                                                                                     |

---

## Ridgeback Software Setup {#ridgeback-software-setup}

### Backing Up Robot Configuration

Upgrading your Clearpath Ridgeback to ROS Noetic from older ROS distributions is a straightforward process;
however it's important to understand that each Ridgeback is different, having undergone customization to your specifications.
For more complete upgrade instructions see [this guide](https://clearpathrobotics.com/assets/guides/melodic/melodic-to-noetic/index.html).

Please take the time to understand what these modifications are, and how to recreate them on your fresh install of Ubuntu Focal/ROS Noetic.

#### Performing a Backup {#performing-a-backup}

<ComponentPerformingABackup />

### Installing and Configuring Robot Software

:::note

If you are upgrading your Ridgeback from an older version of ROS, please refer to our upgrade instructions [here](https://clearpathrobotics.com/assets/guides/kinetic/kinetic-to-melodic/index.html)
and [here](https://clearpathrobotics.com/assets/guides/melodic/melodic-to-noetic/index.html).

:::

#### Installing Ridgeback Software

:::note

The physical Ridgeback robot comes pre-configured with ROS and the necessary Ridgeback packages already installed;
therefore, you will only need to follow the instructions below if you are re-installing software on the Ridgeback.

:::

<ComponentInstallingRobotSoftware />

#### Testing Base Configuration

You can check that the service has started correctly by checking the logs:

```
sudo journalctl -u ros
```

Your Ridgeback should now be accepting commands from your joystick (see next section).
The service will automatically start each time you boot your Ridgeback's computer.

#### Pairing the Controller {#pairing-the-controller}

##### PS4 Controller

<ComponentPs4ControllerPairing />

### Setting up Ridgeback's Network Configuration {#ridgeback-networking}

Ridgeback is normally equipped with a combination Wi-Fi + Bluetooth module.
If this is your first unboxing, ensure that Ridgeback's wireless antennae are firmly screwed on to the chassis.

#### First Connection

By default, Ridgeback's Wi-Fi is in client mode, looking for the wireless network at the Clearpath factory.

<ComponentWiredRobotConnection />

#### Changing the Default Password

<ComponentChangingDefaultPassword />

#### Wi-Fi Setup

<ComponentWifiRobotConnection />

### Installing Remote Computer Software {#remote-computer-software}

:::note

This step is optional.

:::

<ComponentInstallingRemoteComputerSoftware />

#### Adding a Source Workspace

<ComponentAddingASourceWorkspace />

---

## Using Ridgeback {#using-ridgeback}

### Simulating Ridgeback {#simulating-ridgeback}

Whether you actually have a Ridgeback robot or not, the Ridgeback simulator is a great way to get started with ROS robot development.
In this tutorial, we will go through the basics of starting Gazebo and RViz and how to drive your Ridgeback around.

#### Installation

To get started with the Ridgeback simulation, make sure you have a [working ROS installation](#remote-computer-software) set up on your Ubuntu desktop, and install the Ridgeback-specific metapackages for desktop and simulation:

```
sudo apt-get install ros-noetic-ridgeback-simulator ros-noetic-ridgeback-desktop
```

#### Launching Gazebo

[Gazebo](https://gazebosim.org/home) is the most common simulation tool used in ROS. Ridgeback's model in Gazebo include reasonable approximations of its dynamics, including wheel slippage, skidding, and inertia.
To launch simulated Ridgeback in a simple example world, run the following command:

```
roslaunch ridgeback_gazebo ridgeback_world.launch
```

You should see the following window appear, or something like it.
You will see a base Ridgeback spawned with no additional sensors.
You can adjust the camera angle by clicking and dragging while holding CTRL, ALT, or the Shift key.

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_gazebo.png"
      width="800"
    />
    <figcaption>Simulated Ridgeback in the Race World</figcaption>
  </figure>
</center>

The window which you are looking at is the Gazebo Client.
This window shows you the "true" state of the simulated world which the robot exists in.
It communicates on the backend with the Gazebo Server, which is doing the heavy lifting of actually maintaining the simulated world.
At the moment, you are running both the client and server locally on your own machine, but some advanced users may choose to run heavy duty simulations on separate hardware and connect to them over the network.

:::note

When simulating, you must leave Gazebo running.
Closing Gazebo will prevent other tools, such as RViz (see below) from working correctly.

:::

:::note

See also [Additional Simulation Worlds](#additional-sim).

:::

##### Simulation Configs

Note that like Ridgeback itself, Ridgeback's simulator comes in multiple flavours called configs.
A common one which you will need often is the `base_sick` config.
If you close the Gazebo window, and then CTRL-C out of the terminal process, you can re-launch the simulator with a specific config.

```
roslaunch ridgeback_gazebo ridgeback_world.launch config:=base_sick
```

You should now see the simulator running with the simulated SICK LMS-111 laser present.

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_gazebo_laser.png"
      width="800"
    />
    <figcaption>Simulated Ridgeback in the Race World with SICK LMS-111</figcaption>
  </figure>
</center>

Gazebo not only simulates the physical presence of the laser scanner, it also provides simulated data which reflects the robot's surroundings in its simulated world.
We will visualize the simulated laser scanner data shortly.

### Interfacing with Ridgeback

Both simulated and real Ridgeback robots expose the same ROS interface and can be interacted with in the same way.

:::note

Please make sure that the desktop packages for Ridgeback are installed:

```
sudo apt-get install ros-noetic-ridgeback-desktop
```

:::

#### Launching RViz

The next tool we will encounter is [RViz](http://wiki.ros.org/rviz).
Although superficially similar in appearance to Gazebo, RViz has a very different purpose. Unlike Gazebo, which shows the reality of the simulated world, RViz shows the robot's _perception_ of its world, whether real or simulated.
So while Gazebo won't be used with your real Ridgeback, RViz is used with both.

You can use the following launch invocation to start RViz with a predefined configuration suitable for visualizing any standard Ridgeback config.

```
roslaunch ridgeback_viz view_robot.launch
```

You should see RViz appear.

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_rviz.png"
      width="800"
    />
    <figcaption>Ridgeback RViz</figcaption>
  </figure>
</center>

The RViz display only shows what the robot knows about its world, which presently, is nothing.
Because the robot doesn't yet know about the barriers which exist in its Gazebo world, they are not shown here.

#### Driving with Interactive Controller

RViz will also show Ridgeback's interactive markers around your Ridgeback's model.
These will appear as a blue ring and red arrows.
Depending on your robot, there will also be green arrows.
If you don't see them in your RViz display, select the Interact tool from the top toolbar and they should appear.

Drag the red arrows in RViz to move in the linear X direction, and the blue circle to move in the angular Z direction.
If your robot supports lateral/sideways movement, you can drag the green arrows to move in the linear Y direction.
RViz shows you Ridgeback moving relative to its odometric frame, but it is also moving relative to the simulated world supplied by Gazebo.
If you click over to the Gazebo window, you will see Ridgeback moving within its simulated world.
Or, if you drive real Ridgeback using this method, it will have moved in the real world.

#### Visualizing Sensors

The RViz tool is capable of visualizing many common robotic sensors, as well as other data feeds which can give us clues as to what the robot is doing and why.
A great place to start with this is adding the [LaserScan](http://wiki.ros.org/rviz/DisplayTypes/LaserScan) plugin to visualize the laser scans being produced
by the simulated UST-10LX or LMS-111. In the left panel, click the "Add" button, then select the "Topics" tab, and then select the `front/scan` topic:

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_rviz_add_laser.png"
      width="800"
    />
    <figcaption>Adding a laser scan visualization to Ridgeback</figcaption>
  </figure>
</center>

Click "OK" and you should see laser scan points now visible in the RViz window, relative to the robot.

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_rviz_laser.png"
      width="800"
    />
    <figcaption>Visualizing Ridgeback with simulated laser scans</figcaption>
  </figure>
</center>

If you use the interactive markers to drive around, you'll notice that the laser scan points move a little bit but generally stay where they are.
This is the first step toward map making using [Gmapping](#gmapping-demo).

#### Control

There are three ways to send your Ridgeback control commands:

1.  Using the provided PS4 controller.
    Refer to the [User Manual](/docs/robots/indoor_robots/ridgeback/user_manual_ridgeback/#controller) details on how to use the controller.

2.  Using the RViz instance above.
    If you select the Interact option in the top toolbar, an interactive marker will appear around the Ridgeback and can be used to control speed.

3.  The [rqt_robot_steering plugin](http://wiki.ros.org/rqt_robot_steering).
    Run the `rqt` command, and select **Plugins→Robot Tools→Robot Steering** from the top menu.

Ridgeback uses [twist_mux](http://wiki.ros.org/twist_mux) to mix separate [geometry_msgs\Twist](http://docs.ros.org/api/geometry_msgs/html/msg/Twist.html) control channels into the `ridgeback_velocity_controller/cmd_vel` topic.

Additional velocity channels can be defined in [twist_mux.yaml](https://github.com/ridgeback/ridgeback/blob/melodic-devel/ridgeback_control/config/twist_mux.yaml), or can be piped into the lowest-priority `cmd_vel` topic.

#### Odometry

Ridgeback publishes odometry information on the `odometry/filtered` topic, as [nav_msgs/Odometry messages](http://docs.ros.org/api/nav_msgs/html/msg/Odometry.html).
These are generated by [ekf_localization_node](http://wiki.ros.org/robot_localization), which processes data from several sensor sources using an Extended Kalman filter (EKF).
This includes data from the wheel encoders and IMU (if available).

Additional odometry information sources can be added to the EKF in [robot_localization.yaml](https://github.com/ridgeback/ridgeback/blob/melodic-devel/ridgeback_control/config/robot_localization.yaml).

#### Diagnostics

:::note

Diagnostics are only applicable to real Ridgeback robots, not simulation.

:::

Ridgeback provides hardware and software system [diagnostics](http://wiki.ros.org/diagnostics) on the ROS standard `/diagnostics` topic.
The best way to view these messages is using the [rqt_runtime_monitor](http://wiki.ros.org/rqt_runtime_monitor) plugin.
Run the `rqt` command, and select **Plugins→Robot Tools→Runtime Monitor** from the top menu.

The same information is also published as a [ridgeback_msgs\Status](https://docs.ros.org/en/api/ridgeback_msgs/html/msg/Status.html) message on the `Status` topic.

### Driving Ridgeback {#driving-ridgeback}

There are four ways to drive Ridgeback and each way will work on a physical Ridgeback robot as well as on a simulated Ridgeback.

1.  Using the interactive remote controller in RViz. See [Simulating Ridgeback](#simulating-ridgeback).
2.  Using autonomous navigation. See [Navigating Ridgeback](#navigating-ridgeback).
3.  Using the controller for teleoperation. See below.
4.  Publishing ROS messages. See below.

:::warning

Ridgeback is capable of reaching high speeds.
Careless driving can cause harm to the operator, bystanders, the robot, or other property.
Always remain vigilant, ensure you have a clear line of sight to the robot, and operate the robot at safe speeds.
We strongly recommend driving in normal (slow) mode first, and only enabling turbo in large, open areas that are free of people and obstacles.

:::

#### Driving with Remote Controller

:::note

For instructions on controller pairing, see [Pairing the Controller](#pairing-the-controller).

:::

<ComponentDrivingWithRemoteController />

#### Driving with ROS Messages

You can manually publish `geometry_msgs/Twist` ROS messages to either the `/ridgeback_velocity_controller/cmd_vel` or the `/cmd_vel` ROS topics to drive Ridgeback.

For example, in terminal, run:

```
rostopic pub /ridgeback_velocity_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.5, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}'
```

The command above makes Ridgeback drive forward momentarily at 0.5 m/s without any rotation.

### Extending Ridgeback Startup

Now that you've had Ridgeback for a while, you may be interested in how to extend it, perhaps add some more payloads, or augment the URDF.

#### Startup Launch Context

When ROS packages are grouped together in a directory and then built as one, the result is referred to as a workspace.
Each workspace generates a `setup.bash` file which the user may source in order to correctly set up important environment variables such as `PATH`, `PYTHONPATH`, and `CMAKE_PREFIX_PATH`.

The standard system-wide setup file is in `/opt`:

```
source /opt/ros/noetic/setup.bash
```

When you run this command, you'll have access to `rosrun`, `roslaunch`, and all the other tools and packages installed on your system from Debian packages.

However, sometimes you want to add additional system-specific environment variables, or perhaps packages built from source.
For this reason, Clearpath platforms use a wrapper setup file, located in `/etc/ros`:

```
source /etc/ros/setup.bash
```

This is the setup file which gets sourced by Ridgeback's background launch job, and in the default configuration, it is also sourced on your login session.
For this reason it can be considered the "global" setup file for Ridgeback's ROS installation.

This file sets some environment variables and then sources a chosen ROS workspace, so it is one of your primary modification points for altering how Ridgeback launches.

#### Launch Files

The second major modification point is the `/etc/ros/noetic/ros.d` directory.
This location contains the launch files associated with the `ros` background job.
If you add launch files here, they will be launched with Ridgeback's startup.

However, it's important to note that in the default configuration, any launch files you add may only reference ROS software installed in `/opt/ros/noetic`.
If you want to launch something from workspace in the home directory, you must change `/etc/ros/setup.bash` to source that workspace's setup file rather than the one from `/opt`.

#### Adding URDF

There are two possible approaches to augmenting Ridgeback's URDF.
The first is that you may simply set the `Ridgeback_URDF_EXTRAS` environment variable in `/etc/ros/setup.bash`.
By default, it points to an empty dummy file, but you can point it to a file of additional links and joints which you would like mixed into Ridgeback's URDF (via xacro) at runtime.

The second, more sophisticated way to modify the URDF is to create a _new_ package for your own robot, and build your own URDF which wraps the one provided by [ridgeback_description](https://github.com/ridgeback/ridgeback/tree/melodic-devel/ridgeback_description).

### Keeping Ridgeback Updated

For details on updating Ridgeback software or firmware, refer to [Software Maintenance](/docs/robots/indoor_robots/ridgeback/maintenance_ridgeback#software_maintenance).

---

## Navigating Ridgeback {#navigating-ridgeback}

To get all Navigation related files for Ridgeback, run:

```
sudo apt-get install ros-noetic-ridgeback-navigation
```

Below are the example launch files for three different configurations for navigating Ridgeback:

- Navigation in an odometric frame without a map, using only [move_base](http://wiki.ros.org/move_base).
- Generating a map using [Gmapping](http://wiki.ros.org/gmapping).
- Localization with a known map using [amcl](http://wiki.ros.org/amcl).

Referring to the [Simulating Ridgeback](#simulating-ridgeback) instructions, bring up Ridgeback with the front laser enabled for the following demos:

```
roslaunch ridgeback_gazebo ridgeback_world.launch config:=front_laser
```

If you're working with a real Ridgeback, it's suggested to connect via SSH and launch the [ridgeback_navigation](https://github.com/ridgeback/ridgeback/tree/melodic-devel/ridgeback_navigation) launch files from onboard the robot.
You'll need to have bidirectional communication with the robot's roscore in order to launch RViz on your workstation (see [here](#remote-computer-software)).

### Navigation without a Map

In the odometry navigation demo Ridgeback attempts to reach a given goal in the world within a user-specified tolerance.
The 2D navigation, generated by `move_base`, takes in information from odometry, laser scanner, and a goal pose and outputs safe velocity commands.
In this demo the configuration of move_base is set for navigation without a map in an odometric frame (that is, without reference to a map).

To launch the navigation demo, run:

```
roslaunch ridgeback_navigation odom_navigation_demo.launch
```

To visualize with the suggested RViz configuration launch:

```
roslaunch ridgeback_viz view_robot.launch config:=navigation
```

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/rviz-odom-navigation.png"
      width="800"
    />
    <figcaption>RViz with Ridgeback's odom navigation configuration</figcaption>
  </figure>
</center>

To send goals to the robot, select the _2D Nav Goal_ tool from the top toolbar, and then click anywhere in the RViz view to set the position.
Alternatively, click and drag slightly to set the goal position and orientation.

If you wish to customize the parameters of move_base, local costmap, global costmap and base_local_planner, clone [ridgeback_navigation](https://github.com/ridgeback/ridgeback/tree/melodic-devel/ridgeback_navigation) into your own workspace and modify the corresponding files in the `params` subfolder.

### Making a Map {#gmapping-demo}

In this demonstration, Ridgeback generates a map using Gmapping. Begin by launch the Gmapping launch file on the robot:

```
roslaunch ridgeback_navigation gmapping_demo.launch
```

And on your workstation, launch RViz with the suggested configuration:

```
roslaunch ridgeback_viz view_robot.launch config:=gmapping
```

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/rviz-gmapping.png"
      width="800"
    />
    <figcaption>RViz with Ridgeback's Gmapping configuration</figcaption>
  </figure>
</center>

You must slowly drive Ridgeback around to build the map.
As obstacles come into view of the laser scanner, they will be added to the map, which is shown in RViz.
You can either drive manually using the interactive markers, or semi-autonomously by sending navigation goals (as above).

When you're satisfied, you can save the produced map using [map_saver](http://wiki.ros.org/map_server#map_saver):

```
rosrun map_server map_saver -f mymap
```

This will create a `mymap.yaml` and `mymap.pgm` file in your current directory.

### Navigation with a Map

Using [amcl](http://wiki.ros.org/amcl), Ridgeback is able to globally localize itself in a known map.
AMCL takes in information from odometry, laser scanner and an existing map and estimates the robot's pose.

To start the AMCL demo:

```
roslaunch ridgeback_navigation amcl_demo.launch map_file:=/path/to/my/map.yaml
```

If you don't specify `map_file`, it defaults to an included pre-made map of the default "Ridgeback Race" environment which Ridgeback's simulator spawns in.
If you're using a real Ridgeback in your own environment, you'll definitely want to override this with the map created using the Gmapping demo.

Before navigating, you need to initialize the localization system by setting the pose of the robot in the map.
This can be done using 2D Pose Estimate in RViz or by setting the amcl `initial_pose` parameters. To visualize with the suggested RViz configuration launch:

```
roslaunch ridgeback_viz view_robot.launch config:=localization
```

When RViz appears, select the _Set 2D Pose tool_ from the toolbar, and click on the map to indicate to the robot approximately where it is.

---

## Ridgeback Tests {#testing-ridgeback}

Ridgeback robots come preinstalled with a set of test scripts as part of the `ridgeback_tests` ROS package, which can be run to verify robot functionality at the component and system levels.

If your Ridgeback does not have the `ridgeback_tests` ROS package installed already, you can manually install it by opening terminal and running:

```
sudo apt-get install ros-noetic-ridgeback-tests
```

### ROS Tests

The `ros_tests` script exposes a set of interactive tests to verify the functionality of core features.
These tests run at the ROS-level via ROS topics, and serve as a useful robot-level diagnostic tool for identifying the root cause of problems, or at the very least, narrowing down on where the root cause(s) may be.

#### Running ROS Tests

To run `ros_tests` on a Ridgeback robot, open terminal and run:

```
rosrun ridgeback_tests ros_tests
```

Upon running `ros_tests`, a list of available tests will be shown in a menu.
From the menu, you can choose individual tests to run, or simply choose the option to automatically run all the tests.

The details of each test are shown below.

- **Lighting Test**

  The **Lighting Test** checks that the robot's lights are working properly.

  This test turns the lights off, red, green, and blue (in order) by publishing lighting commands to the `/cmd_lights` ROS topic.
  The user will be asked to verify that the lights change to the expected colours.

- **Motion Stop Test**

  The **Motion Stop Test** checks that the robot's motion-stop is working properly.

  This test subscribes to the `/mcu/status` ROS topic and checks that when the motion-stop is manually engaged by the user, the motion-stop state is correctly reported on the `/mcu/status` ROS topic.
  The user will be asked to verify that the lights flash red while the motion-stop is engaged.

- **ADC Test**

  The **ADC Test** checks that the robot's voltage and current values across its internal hardware components are within expected tolerances.

  This test subscribes to the `/mcu/status` ROS topic and checks that the voltage and current values across the internal hardware are within expected tolerances.

- **Rotate Test**

  The **Rotate Test** rotates the robot counter clockwise 2 full revolutions and checks that the motors, IMU, and EKF odometry are working properly.

  This test:

  - Subscribes to the `/imu/data` ROS topic to receive angular velocity measurements from the IMU's Gyroscope.
    These measurements are converted into angular displacement estimations, and the robot will rotate until 2 full revolutions are estimated.
  - Subscribes to the `/odometry/filtered` ROS topic to receive angular velocity estimations from the EKF odometry.
    These measurements are converted into angular displacement estimations, and are output as comparison to the angular displacement estimations from the IMU's Gyroscope.
  - Publishes to the `/cmd_vel` ROS topic to send drive commands to rotate the robot.
  - The user will be asked to verify that the robot rotates 2 full revolutions.

  :::note

  The **Rotate Test** rotates the robot using the IMU's Gyroscope data, which inherently will not be 100% accurate.
  Therefore, some undershoot/overshoot is to be expected.

  :::

- **Drive Test**

  The **Drive Test** drives the robot forward 1 metre and checks that the motors, encoders, and encoder-fused odometry are working properly.

  This test:

  - Subscribes to the `/ridgeback_velocity_controller/odom` ROS topic to receive linear displacement estimations from the encoder-fused odometry.
    The robot will drive forward until 1 metre is estimated.
  - Subscribes to the `/feedback` ROS topic to receive linear displacement measurements from the individual encoders.
    These measurements are output as comparison to the linear displacement estimations from the encoder-fused odometry.
  - Subscribes to the `/joint_state` ROS topic to receive linear displacement measurements from individual the encoders.
    These measurements are output as comparison to the linear displacement estimations from the encoder-fused odometry.
  - Publishes to the `/cmd_vel` ROS topic to send drive commands to drive the robot.
  - The user will be asked to verify that the robot drives forward 1 metre.

  :::note

  The **Drive Test** drives the robot using the Odometry data, which inherently will not be 100% accurate.
  Therefore, some undershoot/overshoot is to be expected.

  :::

- **Cooling Test**

  The **Cooling Test** checks that the fans are working properly.

  This test makes the fans spin at different speeds by publishing fan speed commands to the `/mcu/cmd_fans` ROS topic.
  The user will be asked to verify that the fans change to the expected speeds.

### CAN Bus Test

The `check_can_bus_interface` script checks that communication between the motors, encoders, robot's MCU, and robot's computer are working properly over the CAN bus interface.

This script verifies that the `can0` interface is detected and activated, then proceeds to check the output of `candump` to verify that good CAN packets are being transmitted.

#### Running CAN Bus Test

To run the `check_can_bus_interface` script on a Ridgeback robot, open terminal and run:

```
rosrun ridgeback_tests check_can_bus_interface
```

---

## Advanced Topics

### Configuring the Network Bridge

<ComponentConfiguringNetworkBridge />

### Additional Simulation Worlds {#additional-sim}

In addtion to the default `ridgeback_world.launch` file, `ridgeback_gazebo` also contains
`spawn_ridgeback.launch`, which is intended to be included in any custom world to add a
Ridgeback simulation to it.

To add a Ridgeback to any of your own worlds, simply include the `spawn_ridgeback.launch` file in your own world's launch:

```markup
<include file="$(find ridgeback_gazebo)/launch/spawn_ridgeback.launch">
  <!-- Optionally configure the spawn position -->
  <arg name="x" value="$(arg x)"/>
  <arg name="y" value="$(arg y)"/>
  <arg name="z" value="$(arg z)"/>
  <arg name="yaw" value="$(arg yaw)"/>
</include>
```

Finally, Clearpath provides an additional suite of simulation environments that can be downloaded separately and used with Ridgeback, as described below.

#### Clearpath Gazebo Worlds

The Clearpath Gazebo Worlds collection contains 4 different simulation worlds, representative of different environments our robots are designed to operate in:

- Inspection World: a hilly outdoor world with water and a cave
- Agriculture World: a flat outdoor world with a barn, fences, and solar farm
- Office World: a flat indoor world with enclosed rooms and furniture
- Construction World: office world, under construction with small piles of debris and partial walls

Ridgeback is supported in the Office and Construction worlds.

#### Installation

To download the Clearpath Gazebo Worlds, clone the repository from github into the same workspace as your Ridgeback:

```
cd ~/catkin_ws/src
git clone https://github.com/clearpathrobotics/cpr_gazebo.git
```

Before you can build the package, make sure to install dependencies.
Because Clearpath Gazebo Worlds depends on all of our robot's simulation packages, and some of these are currently only
available as source code, installing dependencies with `rosdep install --from-paths [...]` will likely fail.

To simulate Ridgeback in the Office and Construction worlds the only additional dependency is the `gazebo_ros` package.

Once the dependencies are installed, you can build the package:

```
cd ~/catkin_ws
catkin_make
source devel/setup.bash
```

#### Running the Office Simulation

Office World is a small indoor environment representing a commercial office space. It features several large, open
areas with furniture, as well as a narrow hallway with smaller offices and meeting rooms. It is intended to simulate
missions in commercial spaces, such as facilitating deliveries, security monitoring, and inspecting equipment.

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_office_world.png"
      width="800"
    />
    <figcaption>Ridgeback in the Office World</figcaption>
  </figure>
</center>

To launch Office World with a Ridgeback, run the following command:

```
roslaunch cpr_office_gazebo office_world.launch platform:=ridgeback
```

You should see Ridgeback spawn in the office world, as pictured.

To customize Ridgeback's payload, for example to add additional sensors, see
[Customizing Ridgeback's Payload](#customizing-ridgeback-payloads).

Once the simulation is running you can use RViz and other tools as described
in [Simulating Ridgeback](#simulating-ridgeback) and
[Navigating Ridgeback](#navigating-ridgeback) to control and monitor the robot.
For example, below we can see the `gmapping_demo` from `ridgeback_navigation`
being used to build a map of the office world:

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_office_gmap.png"
      width="800"
    />
    <figcaption>Gmapping in Office World</figcaption>
  </figure>
</center>

You can see the complete layout of the office below:

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/office_world.png"
      width="800"
    />
    <figcaption>The layout of Office World</figcaption>
  </figure>
</center>

#### Running the Construction Simulation

Construction World is the same basic layout as Office World, representing the same office space under construction/renovation.
It is an indoor environment with small hills of debris/rubble, partial walls, and piles of construction supplies. It
is designed to simulate missions in any sort of construction site.

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_construction_world.png"
      width="800"
    />
    <figcaption>Ridgeback in the Construction World</figcaption>
  </figure>
</center>

To launch Construction World with a Ridgeback, run the following command:

```
roslaunch cpr_office_gazebo office_construction_world.launch platform:=ridgeback
```

You should see Ridgeback spawn in the construction world, as pictured.

To customize Ridgeback's payload, for example to add additional sensors, see
[Customizing Ridgeback's Payload](#customizing-ridgeback-payloads).

Once the simulation is running you can use RViz and other tools as described
in [Simulating Ridgeback](#simulating-ridgeback) and
[Navigating Ridgeback](#navigating-ridgeback) to control and monitor the robot.

You can see the complete layout of the office below:

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/construction_world.png"
      width="800"
    />
    <figcaption>The layout of Construction World</figcaption>
  </figure>
</center>

### Customizing Ridgeback's Payload {#customizing-ridgeback-payloads}

To customize Ridgeback's payload you must use the environment variables described in
[ridgeback_description](https://github.com/ridgeback/ridgeback/tree/melodic-devel/ridgeback_description).
For example, to equip Ridgeback with a Sick LMS-111 lidar, as pictured in several of the images above, run

```
export RIDGEBACK_LASER=1
```

before launching the simulation world.

You can also add additional sensors by creating a customized URDF and setting the `RIDGEBACK_URDF_EXTRAS` environment
variable to point to it.

For example, let's suppose you want to equip Ridgeback with an Intel RealSense D435 camera. First, install the `realsense2_camera`
and `realsense2_description` packages, along with the gazebo plugins:

```
sudo apt-get install ros-$ROS_DISTRO-realsense2-camera ros-$ROS_DISTRO-realsense2-description ros-$ROS_DISTRO-gazebo-plugins
```

Then create your customized URDF file, for example `$HOME/Desktop/realsense.urdf.xacro`. Put the following in it:

```xml

  <?xml version="1.0"?>
  <robot xmlns:xacro="http://ros.org/wiki/xacro">

    <link name="front_realsense" />

    <!--
      The gazebo plugin aligns the depth data with the Z axis, with X=left and Y=up
      ROS expects the depth data along the X axis, with Y=left and Z=up
      This link only exists to give the gazebo plugin the correctly-oriented frame
    -->
    <link name="front_realsense_gazebo" />
    <joint name="front_realsense_gazebo_joint" type="fixed">
      <parent link="front_realsense"/>
      <child link="front_realsense_gazebo"/>
      <origin xyz="0.0 0 0" rpy="-1.5707963267948966 0 -1.5707963267948966"/>
    </joint>

    <gazebo reference="front_realsense">
      <turnGravityOff>true</turnGravityOff>
      <sensor type="depth" name="front_realsense_depth">
        <update_rate>30</update_rate>
        <camera>
          <!-- 75x65 degree FOV for the depth sensor -->
          <horizontal_fov>1.5184351666666667</horizontal_fov>
          <vertical_fov>1.0122901111111111</vertical_fov>

          <image>
            <width>640</width>
            <height>480</height>
            <format>RGB8</format>
          </image>
          <clip>
            <!-- give the color sensor a maximum range of 50m so that the simulation renders nicely -->
            <near>0.01</near>
            <far>50.0</far>
          </clip>
        </camera>
        <plugin name="kinect_controller" filename="libgazebo_ros_openni_kinect.so">
          <baseline>0.2</baseline>
          <alwaysOn>true</alwaysOn>
          <updateRate>30</updateRate>
          <cameraName>realsense</cameraName>
          <imageTopicName>color/image_raw</imageTopicName>
          <cameraInfoTopicName>color/camera_info</cameraInfoTopicName>
          <depthImageTopicName>depth/image_rect_raw</depthImageTopicName>
          <depthImageInfoTopicName>depth/camera_info</depthImageInfoTopicName>
          <pointCloudTopicName>depth/color/points</pointCloudTopicName>
          <frameName>front_realsense_gazebo</frameName>
          <pointCloudCutoff>0.105</pointCloudCutoff>
          <pointCloudCutoffMax>8.0</pointCloudCutoffMax>
          <distortionK1>0.00000001</distortionK1>
          <distortionK2>0.00000001</distortionK2>
          <distortionK3>0.00000001</distortionK3>
          <distortionT1>0.00000001</distortionT1>
          <distortionT2>0.00000001</distortionT2>
          <CxPrime>0</CxPrime>
          <Cx>0</Cx>
          <Cy>0</Cy>
          <focalLength>0</focalLength>
          <hackBaseline>0</hackBaseline>
        </plugin>
      </sensor>
    </gazebo>

    <link name="front_realsense_lens">
      <visual>
        <origin xyz="0.02 0 0" rpy="${pi/2} 0 ${pi/2}" />
        <geometry>
          <mesh filename="package://realsense2_description/meshes/d435.dae" />
        </geometry>
        <material name="white" />
      </visual>
    </link>

    <joint type="fixed" name="front_realsense_lens_joint">
      <!-- Offset the camera 45cm forwards and 1cm up -->
      <origin xyz="0.45 0 0.01" rpy="0 0 0" />
      <parent link="mid_mount" />
      <child link="front_realsense_lens" />
    </joint>
    <joint type="fixed" name="front_realsense_joint">
      <origin xyz="0.025 0 0" rpy="0 0 0" />
      <parent link="front_realsense_lens" />
      <child link="front_realsense" />
    </joint>
  </robot>
```

This file defines the additional links for adding a RealSense camera to the robot, as well as configuring the `openni_kinect`
plugin for Gazebo to simulate data from a depth camera. The camera itself will be connected to the Ridgeback's `front_mount`
link, offset 5cm towards the front of the robot.

Now, set the `RIDGEBACK_URDF_EXTRAS` environment variable and try viewing the Ridgeback model:

```
export RIDGEBACK_URDF_EXTRAS=$HOME/Desktop/realsense.urdf.xacro
roslaunch ridgeback_viz view_model.launch
```

You should see the Ridgeback model in RViz, with the RealSense camera mounted to it:

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_rviz_realsense.png"
      width="800"
    />
    <figcaption>Ridgeback with a RealSense D435</figcaption>
  </figure>
</center>

To launch the customized Ridgeback in any of the new simulation environments, similarly run:

```
export RIDGEBACK_URDF_EXTRAS=$HOME/Desktop/realsense.urdf.xacro
roslaunch cpr_office_gazebo office_world.launch platform:=ridgeback
```

You should see Ridgeback spawn in the office world with the RealSense camera:

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_office_realsense.png"
      width="800"
    />
    <figcaption>Ridgeback with a RealSense D435 in Office World</figcaption>
  </figure>
</center>

You can view the sensor data from the RealSense camera by running

```
roslaunch ridgeback_viz view_robot.launch
```

and adding the camera & pointcloud from the `/realsense/color/image_raw` and `/realsense/depth/color/points` topics:

<center>
  <figure>
    <img
      src="/img/robot_images/ridgeback_images/ridgeback_rviz_office_realsense.png"
      width="800"
    />
    <figcaption>Ridgeback with a RealSense in RViz showing pointcloud and RGB topics</figcaption>
  </figure>
</center>

---

## Support {#support}

<Support />
